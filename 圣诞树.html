<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>狗屎狗屎</title>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Roboto&display=swap");

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #001;
        }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            align-items: center;
            z-index: 1;
        }
        
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            border-radius: 10px;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #25902950;
        }
        
        button:active {
            background-color: #00FFFFCC;
        }
        
        .btn {
            background-color: rgba(0, 0, 0, 0.4);
            border: none;
            color: rgba(255, 255, 255, 0.4);
            padding: 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 2px 2px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 0, 1);
        }
        
        #fullscreenBtn {
            font-size: 20px;
        }

        .container {
            margin: 0 auto;
            padding: 2rem;
            position: absolute;
            width: 100%;
            font-family: "Roboto", sans-serif;
            text-shadow: 0 0 5px #000, 0 0 10px #000;
            color: #fff;
            filter: drop-shadow(0 0 10px rgba(0, 0, 50, 0.7))
                    drop-shadow(0 0 15px rgba(0, 0, 0, 0.5))
                    drop-shadow(0 0 20px rgba(0, 0, 0, 0.3));
            z-index: 2;
        }

        /* Phone User */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.25rem;
            }
            .container {
                font-size: 0.8rem;
            }
            .btn {
                font-size: 0.8rem;
            }
            #fullscreenBtn {
                font-size: 0.8rem;
                padding: 8px 15px;
            }
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <div class="container">
        <p><button id="fullscreenBtn">全屏</button></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            console.error('WebGL 2 not supported');
            document.body.innerHTML = 'WebGL 2 is not supported in your browser.';
        }

        const vertexShaderSource = `#version 300 es
        in vec4 aPosition;
        void main() {
            gl_Position = aPosition;
        }`;

        const fragmentShaderSource = `#version 300 es
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;
        uniform vec4 iMouse;
        out vec4 fragColor;

        /*--- BEGIN OF SHADERTOY ---*/

        #define SNOW_SPEED_1 1.11
        #define SNOW_SPEED_2 1.72
        #define SNOW_SPEED_3 1.93
        #define SNOW_SPEED_4 1.54
        #define SNOW_SPEED_5 1.35
        #define SNOW_SPEED_6 1.55
        #define SNOW_SPEED_7 1.25
        #define SNOW_SPEED_8 1.49
        #define SNOW_SPEED_9 1.31
        #define SNOW_PARTICLE_SIZE 0.03
        #define SNOW_GRID_SIZE 4.0
        #define FLOOR_WAVE_AMOUNT 0.4
        #define STAR_HEIGHT 4.2
        #define STAR_SIZE 8.0
        #define STAR_INTENSITY 0.001
        #define MAX_DEPTH 15.0
        #define RAYMARCH_STEPS 64
        #define NEON_STREAK_COUNT 6
        #define NEON_STREAK_SPEED 0.5
        #define NEON_STREAK_INTENSITY 0.05
        #define SPIRAL_LIGHT_COUNT 80.0
        #define SPIRAL_LIGHT_INTENSITY 0.35

        float PI=3.14159265;

        vec2 ObjUnion(vec2 obj0,vec2 obj1){
          if (obj0.x<obj1.x)
            return obj0;
          else
            return obj1;
        }

        vec3 sim(vec3 p,float s){
           vec3 ret=p;
           ret=p+s/2.0;
           ret=fract(ret/s)*s-s/2.0;
           return ret;
        }

        vec2 rot(vec2 p,float r){
           vec2 ret;
           ret.x=p.x*cos(r)-p.y*sin(r);
           ret.y=p.x*sin(r)+p.y*cos(r);
           return ret;
        }

        vec2 rotsim(vec2 p,float s){
           vec2 ret=p;
           ret=rot(p,-PI/(s*2.0));
           ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));
           return ret;
        }

        float rnd(vec2 v){
          return sin((sin(((v.y-1453.0)/(v.x+1229.0))*23232.124))*16283.223)*0.5+0.5; 
        }

        float noise(vec2 v){
          vec2 v1=floor(v);
          vec2 v2=smoothstep(0.0,1.0,fract(v));
          float n00=rnd(v1);
          float n01=rnd(v1+vec2(0,1));
          float n10=rnd(v1+vec2(1,0));
          float n11=rnd(v1+vec2(1,1));
          return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);
        }

        vec3 rainbow(float t) {
            t = fract(t);
            float r = abs(t * 6.0 - 3.0) - 1.0;
            float g = 2.0 - abs(t * 6.0 - 2.0);
            float b = 2.0 - abs(t * 6.0 - 4.0);
            return clamp(vec3(r, g, b), 0.0, 1.0);
        }

        vec2 obj0(in vec3 p){
          if (p.y<0.4)
          p.y+=sin(p.x)*FLOOR_WAVE_AMOUNT*cos(p.z)*FLOOR_WAVE_AMOUNT;
          return vec2(p.y,0);
        }

        vec3 obj0_c(vec3 p){
          float f=
            noise(p.xz)*0.5+
            noise(p.xz*2.0+13.45)*0.25+
            noise(p.xz*4.0+23.45)*0.15;
          float pc=min(max(1.0/length(p.xz),0.0),1.0)*0.5;
          return vec3(f)*0.3+pc+0.5;
        }

        float makeshowflake(vec3 p){
          return length(p)-SNOW_PARTICLE_SIZE;
        }

        float makeShow(vec3 p,float tx,float ty,float tz){
          p.y=p.y+iTime*tx;
          p.x=p.x+iTime*ty;
          p.z=p.z+iTime*tz;
          p=sim(p,SNOW_GRID_SIZE);
          return makeshowflake(p);
        }

        vec2 obj1(vec3 p){
          float f=makeShow(p,SNOW_SPEED_1, 1.03, 1.38);
          f=min(f,makeShow(p,SNOW_SPEED_2, 0.74, 1.06));
          f=min(f,makeShow(p,SNOW_SPEED_3, 0.75, 1.35));
          f=min(f,makeShow(p,SNOW_SPEED_4, 0.94, 1.72));
          f=min(f,makeShow(p,SNOW_SPEED_5, 1.33, 1.13));
          f=min(f,makeShow(p,SNOW_SPEED_6, 0.23, 1.16));
          f=min(f,makeShow(p,SNOW_SPEED_7, 0.41, 1.04));
          f=min(f,makeShow(p,SNOW_SPEED_8, 0.29, 1.31));
          f=min(f,makeShow(p,SNOW_SPEED_9, 1.31, 1.13));  
          return vec2(f,1.0);
        }
         
        vec3 obj1_c(vec3 p){
            return vec3(1,1,1);
        }

        vec2 obj2(vec3 p){
          p.y=p.y-STAR_HEIGHT;
          p=p*STAR_SIZE;
          float l=length(p);
          if (l<2.0){
          p.xy=rotsim(p.xy,2.5);
          p.y=p.y-2.0; 
          p.z=abs(p.z);
          p.x=abs(p.x);
          return vec2(dot(p,normalize(vec3(2.0,1,3.0)))/STAR_SIZE,2);
          } else return vec2((l-1.9)/STAR_SIZE,2.0);
        }

        vec3 obj2_c(vec3 p){
          return vec3(1.0,0.5,0.2) * STAR_INTENSITY;
        }

        vec3 getNeonStreaks(vec3 p, float time) {
            vec3 col = vec3(0.0);
            for (int i = 0; i < NEON_STREAK_COUNT; i++) {
                float fi = float(i);
                float offset = fi * PI * 2.0 / float(NEON_STREAK_COUNT);
                float t = time * NEON_STREAK_SPEED + offset;
                float angle = t + p.y * 0.5;
                float spiralRadius = (2.0 - p.y / 3.0) * 0.9;
                
                vec3 streakPos = vec3(cos(angle) * spiralRadius, p.y, sin(angle) * spiralRadius);
                float dist = length(p.xz - streakPos.xz);
                float heightMatch = smoothstep(0.3, 0.0, abs(p.y - streakPos.y));
                
                vec3 streakCol = rainbow(fi / float(NEON_STREAK_COUNT) + time * 0.1);
                float intensity = NEON_STREAK_INTENSITY / (dist * dist + 0.01) * heightMatch;
                col += streakCol * intensity;
            }
            return col;
        }
         
        vec2 inObj(vec3 p){
          return ObjUnion(ObjUnion(obj0(p),obj1(p)),obj2(p));
        }
         
        void mainImage( out vec4 fragColor, in vec2 fragCoord ){
          vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;
         
          vec3 vuv=normalize(vec3(sin(iTime)*0.3,1,0));
          vec3 vrp=vec3(0,cos(iTime*0.5)+2.5,0);
          vec3 prp=vec3(sin(iTime*0.5)*(sin(iTime*0.39)*2.0+3.5),sin(iTime*0.5)+3.5,cos(iTime*0.5)*(cos(iTime*0.45)*2.0+3.5));
          float vpd=1.5;  
         
          vec3 vpn=normalize(vrp-prp);
          vec3 u=normalize(cross(vuv,vpn));
          vec3 v=cross(vpn,u);
          vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;
          vec3 scp=normalize(scrCoord-prp);
         
          mat4 cm=mat4(
            u.x,   u.y,   u.z,   -dot(u,prp),
            v.x,   v.y,   v.z,   -dot(v,prp),
            vpn.x, vpn.y, vpn.z, -dot(vpn,prp),
            0.0,   0.0,   0.0,   1.0);
         
          vec4 pc=vec4(0,0,0,0);
          const float maxl=SPIRAL_LIGHT_COUNT;
          for(float i=0.0;i<maxl;i++){
          vec4 pt=vec4(
            sin(i*PI*2.0*7.0/maxl)*2.0*(1.0-i/maxl),
            i/maxl*4.0,
            cos(i*PI*2.0*7.0/maxl)*2.0*(1.0-i/maxl),
            1.0);
          pt=pt*cm;
          vec2 xy=(pt/(-pt.z/vpd)).xy+vPos*vec2(iResolution.x/iResolution.y,1.0);
          float c;
          c=SPIRAL_LIGHT_INTENSITY/length(xy);
          pc+=vec4(
                  (sin(i*5.0+iTime*10.0)*0.5+0.5)*c,
                  (cos(i*3.0+iTime*8.0)*0.5+0.5)*c,
                  (sin(i*6.0+iTime*9.0)*0.5+0.5)*c,0.0);
          }
          pc=pc/maxl;

          pc=smoothstep(0.0,1.0,pc);
          
          vec2 s=vec2(0.1,0.0);
          vec3 c,p,n;
         
          float f=1.0;
          for(int i=0;i<RAYMARCH_STEPS;i++){
            if (abs(s.x)<.001||f>MAX_DEPTH) break;
            f+=s.x;
            p=prp+scp*f;
            s=inObj(p);
          }
          
          vec3 neonEffect = getNeonStreaks(p, iTime);
          
          if (f<MAX_DEPTH){
            if (s.y==0.0)
              c=obj0_c(p);
            else if (s.y==1.0)
              c=obj1_c(p);
            else
              c=obj2_c(p);
              if (s.y<=1.0){
                fragColor=vec4((c*max(1.0-f*.08,0.0)+neonEffect),1.0)+pc;
              } else{
                 const float n_er=0.01;
                 float v1=inObj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;
                 float v2=inObj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;
                 float v3=inObj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;
                 float v4=inObj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;
                 n=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
          
                float b=max(dot(n,normalize(prp-p)),0.0);
                fragColor=vec4((b*c+pow(b,8.0))*(1.0-f*.01)+neonEffect,1.0)+pc;
              }
          }
          else fragColor=vec4(0,0,0,0)+pc;
        }

        /*--- END OF SHADERTOY ---*/

        void main() {
            mainImage(fragColor, gl_FragCoord.xy);
        }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, 'aPosition');
        const resolutionUniformLocation = gl.getUniformLocation(program, 'iResolution');
        const timeUniformLocation = gl.getUniformLocation(program, 'iTime');
        const mouseUniformLocation = gl.getUniformLocation(program, 'iMouse');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        gl.useProgram(program);

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = canvas.height - e.clientY;  // Flip Y coordinate
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();  // Call once to set initial size

        function render(time) {
            gl.uniform3f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height, 1.0);
            gl.uniform1f(timeUniformLocation, time * 0.001);
            gl.uniform4f(mouseUniformLocation, mouseX, mouseY, 0.0, 0.0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        // Fullscreen toggle functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', toggleFullScreen);

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
    </script>
</body>
</html>